/*
 Navicat MySQL Data Transfer

 Source Server         : admin123
 Source Server Type    : MySQL
 Source Server Version : 80028
 Source Host           : localhost:3306
 Source Schema         : react_blog

 Target Server Type    : MySQL
 Target Server Version : 80028
 File Encoding         : 65001

 Date: 14/08/2022 14:34:49
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for admin_user
-- ----------------------------
DROP TABLE IF EXISTS `admin_user`;
CREATE TABLE `admin_user` (
  `id` int NOT NULL,
  `userName` varchar(255) DEFAULT NULL,
  `passWord` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;

-- ----------------------------
-- Records of admin_user
-- ----------------------------
BEGIN;
INSERT INTO `admin_user` VALUES (1, 'stevewen', '123456');
INSERT INTO `admin_user` VALUES (2, 'admin', '123');
COMMIT;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '文章编号',
  `type_id` int NOT NULL COMMENT '文章类型编号',
  `title` text CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '标题',
  `introduce` text CHARACTER SET utf8 COLLATE utf8_general_ci COMMENT '文章简介',
  `article_content` text CHARACTER SET utf8 COLLATE utf8_general_ci COMMENT '文章主体内容',
  `addTime` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '文章发布时间',
  `view_count` int DEFAULT NULL COMMENT '浏览次数',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb3;

-- ----------------------------
-- Records of article
-- ----------------------------
BEGIN;
INSERT INTO `article` VALUES (3, 1, 'git使用说明', '*Git* 是一个版本控制系统(*Version Control System，VCS* )。版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。有了版本控制系统，就可以不用担心文件丢失，不小心误修改文件等等“事故”，而且你可以随便回到历史记录的某个时刻，*git* 并不是什么高大上的东西，git就是一个用于版本控制的软件，基于*liunx* 命令，通过命令，程序员可以在团队协作中很好的整合代码,更新版本、回退版本。简单举个例子：可一个系统的开发可以分成多个模块，每个模块一个小团队开发，小团队开发完后，通过 *git* 命令便可以轻松合并。', '### 1.git提交文件\n\n```git add -m \"this is a readme.txt\". \ngit add readme.txt\ngit add -m \"this is a readme.txt\". \n```\n\n### 2. 工作区与暂存区\n\n```git\ngit add //会将文件存放到暂存区中\ngit commit //会将暂存区中的文件一次性存入分支中\n```\n\n### 3. 管理的是“修改”，并不是文件。\n\nGit是如何跟踪修改的，每次修改，如果不用 **git add**  到暂存区，那就不会加入到**commit** 中。\n\n### 4. 连接gtihub远程仓库\n\n```ssh-keygen -t rsa\nssh-keygen -t rsa 创建公钥私钥\ngit remote add origin git@github.com:InitialD1/learngit.git\n```\n\n### 5.分支 \n\n```\n查看分支：git branch\n创建分支：git branch <name>\n切换分支：git checkout <name>或者git switch <name>\n创建+切换分支：git checkout -b <name>或者git switch -c <name>\n合并某分支到当前分支：git merge <name>\n删除分支：git branch -d <name>\n```\n\n\n', '2018-07-20 15:34:09', 2222);
INSERT INTO `article` VALUES (4, 1, 'HTML', '超文本标记语言（英語：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。 HTML是一种基础技术，常与CSS、JavaScript一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面。 网页浏览器可以读取HTML文件，并将其渲染成可视化网页。', '## HTML是什么？\n\n1. HTML即HyperText Markup Language,超文本标记语言\n2. HyperText(超文本)不单单是指纯文字的格式，而是指一些图片、标题、链接、表格等更丰富的格式，HTML即使用Markup language（标记语言）来表示这些超文本\n3. Markup language是使用标签来表示超文本内容的，在标签内部可以添加一些属性来引入其他内容\n4. 超文本标记语言（英語：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。 HTML是一种基础技术，常与CSS、JavaScript一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面。 网页浏览器可以读取HTML文件，并将其渲染成可视化网页。\n\n## HTML小知识\n\n1. 在HTML代码开头的标签（!doctype html）用来指明当前网页的HTML版本，浏览器会根据当前的HTML版本来选择使用哪种渲染模式对网页进行渲染，如果没有该语句，浏览器会选择老旧的渲染模式（怪异模式）来渲染网页，这可能会导致实际页面与预想的不一致\n2. html是网页的根标签，其他的标签都是写在html标签内部的\n3. head标签内部放页面的元数据，即渲染页面需要的东西，但是又不需要直接呈现在页面上的数据，比如页面使用的编码，页面的标题\n4. body标签里面放入的是真正需要呈现给用户的数据\n5. src和href的区别？\n   嵌入到当前页面中的内容一般使用src引入，比如图片、音频、视频等嵌入到页面中的内容一般使用src属性；链接到页面外部的内容一般使用href,比如点击超链接跳转到其他页面使用href;\n6. 目前绝大多数场景下不需要考虑兼容IE浏览器了\n7. 为什么用a和img、script等标签访问链接不受跨域的影响？\n   这是这些标签的自有特性，在早期定义标签的时候就已经决定了，现在更新的标签需要兼容以前的特性，所以这些标签访问的链接不受跨域的影响。\n8. 组件库也需要注意语义化\n9. 现在比较倾向于语义化标签，所以在以后的日常工作中语义化要加强，使用div和span这些标签的量要减少，或者需要给其添加属性，让搜索引擎知道div和span的含义，但是一般这样比较麻烦，所以一般推荐使用现在更新的语义化标签。\n\n## 浏览器如何渲染HTML文件\n\n1. 浏览器会将拿到的HTML文档渲染成一个DOM树的结构，树中的每一个节点称为DOM节点，如下图，是一个最简单的HTML文档的DOM树\n\n![20220116131149.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71238b1cecd44611a652820cbdf930bb~tplv-k3u1fbpfcp-watermark.awebp?)\n\n## HTML语法\n\n1. 标签和属性不区分大小写，推荐小写\n2. 空标签（标签体里面没有内容）可以不闭合（不写结束标签），比如input、meta\n3. 属性值推荐用双引号包裹\n4. 某些属性值可以省略，比如required,readonly\n\n## 什么是语义化\n\n1. HTML在版本迭代中增加和删除了很多标签，使得**HTML中的元素、属性及属性值都拥有某些具体的含义**，这就是HTML标签的语义化；\n\n2. HTML标签的语义化能够更清楚的表达网页的内容和结构，所以**开发者在选择和使用HTML标签来编写网页结构时，需要遵循语义化原则**\n\n3. 语义化举例：有序列表用ol;无序列表用ul;lang属性表示网页内容所使用的语言\n\n4. 语义化的好处：\n   (1)提高代码的可读性和可维护性\n   (2)便于搜索引擎优化\n   (3)提升无障碍性\n   \n5. 谁在使用我们写的HTML\n   (1) 开发者-----修改和维护页面，所以使用同一套标准非常重要，可以避免混乱，提高效率\n   (2) 浏览器-----展示页面\n   (3)搜索引擎---提取关键词，排序\n   (4)屏幕阅读器-给盲人读页面内容\n   \n6. **由于语义化的优点和使用HTML的用户对HTML文档的需求决定了语义化标准的重要性，作为开发者，在编写网页结构时要遵循语义化**。\n\n7. 如何做到语义化？\n   (1)多看文档，了解每个标签及其属性的含义\n   (2)思考什么标签最适合描述什么内容\n   (3)不适用可视化工具生成代码，手动编写代码更能加深记忆\n   \n   ', '2022-08-09 22:33:08', 111);
INSERT INTO `article` VALUES (5, 1, 'CSS笔记', '盒模型是CSS的核心概念，描述了元素如何显示，以及在一定程度上如何相互作用、相互影响。页面中的所有元素都被看作一个矩形盒子，这个盒子包含元素的内容、内边距、边框和外边距。内边距是内容周围的空间，当给元素填充背景时会作用到元素的内容区域和内边距区域。边框会在内边距外且紧挨着内边距。边框的外侧是外边距，外边距是围绕在盒子可见部分之外的透明区域，用于控制元素之间的距离。', '---\n\n# 盒模型\n## content-box\n盒模型是CSS的核心概念，描述了元素如何显示，以及在一定程度上如何相互作用、相互影响。页面中的所有**元素**都被看作一个**矩形盒子**，这个盒子包含元素的**内容**、**内边距**、**边框**和**外边距**。\n**	内边距**是内容周围的空间，当给元素填充背景时会作用到元素的内容区域和内边距区域。边框会在内边距外且紧挨着内边距。边框的外侧是外边距，**外边距**是围绕在盒子可见部分之外的透明区域，**用于控制元素之间的距离**。\n默认情况下，**width**和**height**是指盒子的**内容区域**的大小，如果此时给盒子添加**内边距**或**边框**，那么会导致整个盒子变大。\n## border-box\n 默认盒模型的width和height只会作用于盒子的内容区，而通过**\"box-sizing\"**属性可以改变计算盒子大小的方式。\"box-sizing\"的默认值为\"content-box\"，即上一题看到的那样，把值只作用于内容区。现在给类名为\"border-box\"的盒子设置\"box-sizing\"属性为**\"border-box\"**，此时width和height的值不仅会作用于**内容区**，并且**还会包括内边距和边框**。\n很多人将\"border-box\"称为怪异盒模型，其实并不怪异。因为现实中的盒子就是这样测量的。比如快递盒，当用安全气囊包裹易碎物品时，填充物就可以视为\"padding\"，无论填充物有多厚，也不会影响盒子的整体大小。\n\n## 外边距折叠\n常规块盒子有一种机制叫外边距折叠，即垂直方向上的两个外边距相遇时，会折叠成一个外边距，且折叠之后的外边距高度为两者之中较大的那一个\n如果想要清除两个盒子之间的外边距折叠，可以给目标盒子设置以下属性：\n\n- display: inline-block\n- float属性值不是\"none\"的元素\n- 绝对定位\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=utf-8>\n    <style type=\"text/css\">\n      * {\n        margin: 0;\n        padding: 0;\n      }\n      .top {\n        width: 100px;\n        height: 100px;\n        margin: 10px;\n      }\n      .bottom {\n        width: 100px;\n        height: 100px;\n        margin: 10px;\n        position: absolute;\n      }\n    </style>\n  </head>\n  <body>\n    <section class=\"top\"></section>\n    <section class=\"bottom\"></section>\n  </body>\n</html>\n```\n# 浮动\n描述：\n浮动盒子可以向左、右移动，直到它的外边沿接触父级的外边沿或另一个浮动盒子的外边沿。**浮动盒子会脱离常规文档流**，所以文档流中的元素几乎认为浮动盒子不存在。\n## 浮动清除\n浮动元素会脱离文档流，因此不会影响其他元素。但在之前介绍浮动盒子时提到了\"文档流中的元素几乎认为浮动盒子不存在\"，实际上被浮动盒子覆盖的区域中的文本内容会识别到浮动盒子并且绕开浮动盒子。\n现在给类名为\"media\"的盒子设置\"float: left\"属性，让该盒子成为浮动盒子，背景色可以自定义便于观察。此时可以观察到盒子下方的文字内容跑到了盒子右侧。通过调试工具可以发现，两个\"p\"标签被浮动元素所覆盖，并且内部的文字识别到了浮动元素从而绕开了浮动元素。如果给\"section\"元素添加边框，就会发现\"section\"这个父级盒子的高度只有两个\"p\"标签那么高，并没有将浮动元素的高度计算进去，这样会让布局很困难。\n clear属性的值有\"left\"、\"right\"、\"both\"和\"none\"，用于指定盒子的那一侧不应该紧挨着浮动盒子。现在再给类名为\"clear-left\"的\"p\"标签设置\"clear: left\"属性，现在可以发现\"universe\"文本到了浮动盒子的下方并且\"section\"盒子的高度也发生了变化，该高度包含了浮动盒子的高度。\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=utf-8>\n        <style type=\"text/css\">\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            .media {\n                width: 100px;\n                height: 100px;\n            }\n        </style>\n    </head>\n    <body>\n    	<section>\n            <div class=\"media\"></div>\n            <p>hello</p>\n            <p class=\"clear-left\">universe</p>\n        </section>\n    </body>\n</html>\n```\n# 定位\nCSS **position**属性用于指定一个元素在文档中的定位方式。[top](https://developer.mozilla.org/zh-CN/docs/Web/CSS/top)，[right](https://developer.mozilla.org/zh-CN/docs/Web/CSS/right)，[bottom](https://developer.mozilla.org/zh-CN/docs/Web/CSS/bottom) 和 [left](https://developer.mozilla.org/zh-CN/docs/Web/CSS/left) 属性则决定了该元素的最终位置。\n## static\n在流中的元素定位属性值默认都为\"static\"，即**没有定位**。此时元素会忽略**\"top\"、\"bottom\"、\"left\"、\"right\"和\"z-index\"**定位属性。\n现在给\"section\"盒子设置\"left: 10px\"，这时会发现定位属性无效。\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=utf-8>\n        <style type=\"text/css\">\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            section {\n                left: 10px;\n                width: 100px;\n                height: 100px;\n                background-color: black;\n            }\n        </style>\n    </head>\n    <body>\n    	<section></section>\n    </body>\n</html>\n```\n## inherit\n当一个元素的定位属性设置为\"inherit\"时，表示**从父元素继承定位属性**。现在虽然类名为\"inner\"的里盒子设置了\"left: 10px\"属性，但是这是无效的，因为该盒子的定位属性值为\"static\"。现在给里盒子添加\"position: inherit\"属性，表示从类名为\"outer\"的父级外盒子继承定位属性，现在发现里盒子的\"left: 10px\"属性依然没有生效，因为外盒子的定位值依然是\"static\"。最后再给外盒子添加\"position: relative\"属性，此时会发现里盒子向右移动了10px，定位属性\"left\"生效了。\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=utf-8>\n        <style type=\"text/css\">\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            .outer {\n                position: relative;\n                width: 100px;\n                height: 100px;\n                background-color: black;\n            }\n            .inner {\n                position: inherit;\n                left: 10px;\n                width: 80px;\n                height: 80px;\n                background-color: red;\n            }\n        </style>\n    </head>\n    <body>\n    	<section class=\"outer\">\n            <section class=\"inner\">\n                \n            </section>\n        </section>\n    </body>\n</html>\n```\n## absolute\n**绝对定位会把元素拿出文档流，不会再占据原来的空间**。绝对定位元素的**父级**是距离该元素最近的定位祖先，也就是**\"position\"属性不为\"static\"的最近任意祖先**。如果没有这个定位祖先，那么绝对定位元素就相对于文档的根元素\"html\"进行定位。\n 	当前类名为\"outer\"、\"middle\"、\"inner\"的盒子（外、中、里盒子）嵌套在一起，现在给三个盒子均设置左内边距10px，再自定义盒子背景颜色以便于观察。再给里盒子设置绝对定位属性\"position: absolute\"，会发现里盒子的位置并没有发生改变，因为**绝对定位的默认位置**是当前**绝对定位盒子在流中的位置**。继续给里盒子设置\"left: 0px\"属性，观察到里盒子是根据最外层盒子定位的，直接绕过了中间盒子，这是由于中间盒子的定位属性为默认的\"static\"，此时再给中间盒子设置定位属性\"position: absolute\"，会发现里盒子现在是根据中间盒子重新定位的。\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=utf-8>\n        <style type=\"text/css\">\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            .outer {\n                width: 100px;\n                height: 100px;\n                padding-left: 10px;\n                background-color: red;\n            }\n            .middle {\n                position: absolute;\n                width: 100px;\n                height: 100px;\n                padding-left: 10px;\n                background-color: green;\n            }\n            .inner {\n                position: absolute;\n                left: 0px;\n                width: 100px;\n                height: 100px;\n                padding-left: 10px;\n                background-color: blue;\n            }\n        </style>\n    </head>\n    <body>\n    	<div class=\"outer\">\n            <div class=\"middle\">\n                <div class=\"inner\">\n                    \n                </div>\n            </div>\n        </div>\n    </body>\n</html>\n```\n## absolute--评注\n绝对定位非常适合创建**弹出层、提示和对话框等覆盖于其他内容之上**的组件。比如有一篇文章，可以给文章添加一些行内的评注，最好以气泡图的样式显示在文章外部的空白区域中。\n 	**绝对定位的元素默认会待在自己还在流中时的地方**，现在给\"aside\"盒子设置绝对定位属性\"position: absolute\"，此时\"aside\"盒子从流中出来并且覆盖住了下方的元素，现在可以将它向左移动一些，把它定位到文章内容的左边。\"article\"盒子的左外边距为10rem，想让\"aside\"评注放在左边空白处的中间，需要进行计算，这里省略计算步骤。现在只需要将评注组件向左移动9rem即可。现在给评注组件设置\"margin-left: -9rem\"，在CSS中，负边距是完全有效的，负左外边距可以将元素往左拉，其他有趣的效果这里不做赘述。此时观察效果，评注在\"相煎何太急？\"内容的左边，可以很醒目的告诉读者该句的意思。\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=utf-8>\n        <style type=\"text/css\">\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            article {\n                margin-left: 10rem;\n            }\n            aside {\n                position: absolute;\n                width: 5rem;\n                margin-left: -9rem;\n                padding: 1rem;\n                color: white;\n                background-color: pink;\n                border-radius: 0.5rem;\n            }\n            aside:after {\n                content: \'\';\n                position: absolute;\n                display: block;\n                width: 0;\n                height: 0;\n                border: 0.5rem solid pink;\n                border-bottom-color: transparent;\n                border-right-color: transparent;\n                right: -1rem;\n                top: 0.5rem;\n            }\n            .note {\n                color: green;\n                text-decoration-line: underline;\n            }\n        </style>\n    </head>\n    <body>\n    	<section>\n            <article>\n                <p>煮豆燃豆萁，</p>\n                <p>豆在釜中泣。</p>\n                <p>本是同根生，</p>\n                <aside>豆秸怎能这样急迫地煎熬豆子呢？</aside>\n                <p class=\'note\'>相煎何太急？</p>\n            </article>\n        </section>\n    </body>\n</html>\n```\n## z-index\n**z-index**属性设置元素的**堆叠顺序**，拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的上面。z-index可以设置为负数，且该属性**只能作用于定位元素**。\n	 现在给\"img\"图片标签添加\"position: absolute\"、\"left: 0px\"和\"top: 0px\"属性，此时会发现图片被定绝对定位在了页面的左上角，并且遮挡住了下方的内容。现在继续给图片标签添加\"z-index: -1\"属性，现在图片堆叠在了字体内容的下方。\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=utf-8>\n        <style type=\"text/css\">\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            img {\n                position: absolute;\n                left: 0px;\n                top: 0px;\n                z-index: -1;\n            }\n        </style>\n    </head>\n    <body>\n    	<h1>The countdown to Christmas starts here.</h1>\n        <img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fuploads.xuexila.com%2Fallimg%2F1912%2F1135-191202143454.jpg&refer=http%3A%2F%2Fuploads.xuexila.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1639984107&t=eca951193e736a17eb96278117bcfb1f\" width=\"100\">\n        <p>由于图像的 z-index 是 -1，因此它在文本的后面出现。</p>\n    </body>\n</html>\n```\n## relative\n**相对定位的元素仍然会待在原来的地方，即不会从流中出来**。此后可以通过\"top\"、\"right\"、\"bottom\"和\"left\"属性使元素相对于初始位置进行移动。现在给类名为\"center\"的盒子设置相对定位属性\"position: relative\"、设置\"left: 50px\"、设置\"top: 50px\"，再自定义背景颜色以便于观察。此时可以观察到中间盒子在原始的位置上向右、向下均移动了50px的距离，并且**保留了原来的空间**。\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=utf-8>\n        <style type=\"text/css\">\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            .left {\n                background-color: red;\n                width: 100px;\n                height: 100px;\n            }\n            .center {\n                position: relative;\n                top: 50px;\n                left: 50px;\n                background-color: green;\n                width: 100px;\n                height: 100px;\n            }\n            .right {\n                background-color: blue;\n                width: 100px;\n                height: 100px;\n            }\n        </style>\n    </head>\n    <body>\n    	<div class=\"left\"></div>\n        <div class=\"center\"></div>\n        <div class=\"right\"></div>\n    </body>\n</html>\n```\n## fixed\n**固定定位**是由绝对定位衍生出来的，不同之处在于，**固定定位元素**的**父级**始终是**视口**。因此固定定位可以用来创建**始终停留在窗口相同位置**的元素。比如：**固定侧栏**、**固定顶栏**等。这样方便用户，不必再费事寻找栏目。\n 现在给\"nav\"盒子设置固定定位属性\"position: fixed\"、设置\"top: 0\"、设置自定义宽度、背景颜色。此时滑动滚轮，可以发现\"nav\"盒子始终固定在页面的最上方。但是，数字1却被覆盖了。由于**固定定位的盒子不在流中**，所以遮盖住了下方的元素。此时再给\"section\"盒子设置上外边距为1rem，此时1数字正常出现了。固定定位需要注意下方是否有元素被遮挡。\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=utf-8>\n        <style type=\"text/css\">\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            nav {\n                position: fixed;\n                top: 0;\n                width: 200px;\n                background-color: lightblue;\n            }\n            section {\n                margin-top: 1rem;\n            }\n        </style>\n    </head>\n    <body>\n    	<nav>\n</nav>\n        <section>1\n2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</section>\n    </body>\n</html>\n```\n**fixed - 广告**\n**固定定位**不仅可以用于导航栏目，还可以用于控制中心、广告、重要提示内容等。本节使用固定定位实现一个广告牌功能，关闭按钮和该按钮的功能已给出，当点击按钮时，广告牌会消失。现在给类名为\"advert\"的盒子设置固定定位属性\"position: fixed\"、设置\"right: 0\"、设置\"bottom: 0\"，此时广告牌的位置被固定在了视口的右下方。现在还需要将关闭按钮定位在广告牌的右上方，继续给类名为\"x\"的按钮盒子设置绝对定位属性\"position: absolute\"、设置\"right: 0\"，观察按钮的位置，已经被定位在了广告牌的右上方。一个简易的广告牌就设计完成了。\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=utf-8>\n        <style type=\"text/css\">\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            .advert {\n                position: fixed;\n                right: 0;\n                bottom: 0px;\n                width: 300px;\n                height: 200px;\n                background-color: black;\n            }\n            .advert .x {\n                position: absolqute;\n                right: 0;\n            }\n            .advert:first-line {\n                color: white;\n            }\n        </style>\n    </head>\n    <body>\n    	<section class=\"advert\">\n            广告文案\n            <button class=\"x\">x</button>\n        </section>\n\n        <script>\n            document.querySelector(\'button\').onclick = function() {\n                this.parentNode.style.display = \'none\'\n            }\n        </script>\n    </body>\n</html>\n```\n# display\n**display** 属性可以设置元素的内部和外部显示类型 _display types_。元素的外部显示类型 _outer display types_ 将决定该元素在[流式布局](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout)中的表现（[块级或内联元素](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout)）；元素的内部显示类型 _inner display types_ 可以控制其子元素的布局（例如：[flow layout](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout)，[grid](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout) 或 [flex](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout)）。\n## display-flex\nFlexbox，也就是Flexible Box Layout模块，是CSS提供的用于布局的一套新属性。这套属性包含针对**容器**、**容器直接子元素**（弹性项）的两类属性。Flexbox可以控制弹性项的这几个方面：\n1. 大小，基于内容以及可用空间\n2. 流动方向，水平还是垂直，正向还是反向\n3. 两个轴向上的对齐与分布\n4. 顺序，与源代码中的顺序无关\n现在给\"ul\"标签添加\"display: flex\"属性，让该列表成为flex容器，注意：除非另有声明，否则该属性默认弹性项排列方向为正横向，即\"flex-direction: row\"。现在可以看到，列表内容已经是水平排列，并且根据各自的内容宽度进行了收缩。现在对主轴（即\"flex-direction\"属性声明的轴向）进行排列，该属性为\"justify-content\"且默认值为\"flex-start\"，现在给\"ul\"标签设置\"justify-content: center\"属性，可以发现弹性项在主轴上已经居中了。但是此时会发现由于\"home\"的字体比其他字体大，所以弹性项在辅轴（与主轴对应的另一方向的轴）上并没有对其，这是由于控制辅轴对齐方式的\"align-items\"属性默认为\"stretch\"即拉伸，会占满\"ul\"的所有高度空间，并且该行的基线是默认的。现在再给\"ul\"标签添加\"align-items: center\"属性，会发现\"li\"标签此时没有撑满\"ul\"标签的高度，并且在辅轴上是居中对齐的，如果给该属性设置\"baseline\"值，仅仅会在辅轴上将内容文字对齐。\n\n> **主轴的对齐方式：justify-content: center**\n> **交叉轴的对齐方式：align-items: center**\n> - **justify-content** 属性定义了浏览器之间，如何分配顺着弹性容器**主轴** (或者网格行轴) 的元素之间及其周围的空间。\n> \njustify-content: center; //居中排列\n> - **align-items** 属性将所有直接子节点上的 align-self 值设置为一个组。align-self 属性设置项目在其包含块中在**交叉轴**方向上的对齐方式。\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=utf-8>\n        <style type=\"text/css\">\n            * {\n                margin: 0;\n                padding: 0;\n                box-sizing: border-box;\n            }\n            nav ul {\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                height: 2rem;\n                list-style: none;\n            }\n            nav ul li {\n                border: 1px solid black;\n            }\n            nav ul li:first-child {\n                font-size: 1.2rem;\n            }\n        </style>\n    </head>\n    <body>\n    	<nav>\n            <ul>\n                <li>home</li>\n                <li>spaceships</li>\n                <li>planets</li>\n                <li>stars</li>\n            </ul>\n        </nav>\n    </body>\n</html>\n```\n## display-grid\n[CSS 网格布局](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout)引入了二维网格布局系统，可用于布局页面主要的区域布局或小型组件。\nGrid，即**网格布局**。它将页面划分为一个个网格，可以任意组合不同的形态，做出理想的布局效果。Grid布局与Flexbox布局的区别在于，Flexbox是根据轴线对弹性项进行排列，而Grid布局是将容器划分为行和列，产生单元格，然后再对单元格进行操作。\n 	采用网格布局的区域称为容器。容器内部采用网格定位的每个子元素称为容器项，也是单元格。划分网格的线称为网格线，比如，3x3的网格有4条水平网格线和4条垂直网格线。\n 	现在给section盒子设置\"display: grid\"属性，将该盒子变成一个容器。现在需要通过给该容器划分行和列来生成单元格，给容器设置\"grid-template-rows: 100px\"和\"grid-template-columns: repeat(2, 1fr)\"两条属性以生成一个Nx2的网格，且每个容器项的宽度比为1:1、第一行的高度为100px（注意：实际上行高度可以不用设置，会根据每个容器项自动撑开，但如果设置了，就要考虑清除需要多少行，当前的行值100px仅为第一行，如果需要前三行都为100px，需要设置为\"grid-template-rows: 100px 100px 100px\"）。repeat方法可以简化属性值的书写，为了方便表示比例关系，网格布局提供了fr关键字，该关键字和flex-grow颇为相似。实际上如果想固定大小，完全可以将单位全部设置为固定的px值。现在继续给容器添加\"grid-gap: 10px\"属性，该属性为\"grid-row-gap\"和\"grid-column-gap\"两个属性的简写，分别代表行间距和列间距。\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=utf-8>\n        <style type=\"text/css\">\n            * {\n                margin: 0;\n                padding: 0;\n                box-sizing: border-box;\n            }\n            section {\n                display: grid;\n                grid-template-columns: repeat(2,1fr);\n                grid-template-rows: 100px;\n                grid-gap: 10px;\n                width: 500px;\n                text-align: center;\n            }\n            article {\n                height: 100px;\n                border: 1px solid black;\n            }\n        </style>\n    </head>\n    <body>\n    	<section>\n            <article>1</article>\n            <article>2</article>\n            <article>3</article>\n            <article>4</article>\n            <article>5</article>\n            <article>6</article>\n            <article>7</article>\n            <article>8</article>\n            <article>9</article>\n        </section>\n    </body>\n</html>\n```\n\n', '2022-08-09 22:50:50', 1556);
INSERT INTO `article` VALUES (6, 1, 'LeetCode_JavaScript', '二叉树解题的思维模式分两类：1.是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。', '# 二叉搜索树\n\n## 给你一个二叉树的根结点，判断其是否是一棵二叉搜索树\n\n> 方法一：递归\n> 思路分析：\n> 如果该二叉树的左子树不为空，则左子树上所有节点的值都小于它的根结点的值；\n> 如果该二叉树的柚子树不为空，则右子树上所有节点的值都大于它的根结点的值\n> 复杂度分析：时间复杂度：O(n), 空间复杂度：O(n)\n\n```javascript\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {boolean}\n*/\nconst helper = (root, lower, upper) => {\n  if (root == null) return true\n  if (root.val >= upper || root.val <= lower) return false\n  return helper(root.left, lower, root.val) && helper(root.right, root.val, upper)\n}\nvar isValidBST = function(root) {\n  return helper(root, - Infinity, Infinity)\n};\n```\n\n> 方法二：中序遍历\n> 思路分析：中序遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false。\n> 复杂度分析：\n>\n> - 时间复杂度：O(N)\n> - 空间复杂度:   O(1)\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\n\nvar isValidBST = function(root) {\n    let preVal = -Infinity\n    let flag = true\n    const inOrder = (node) => {\n        //如果已经不满足BST，就没有必要继续遍历下去了\n        if (!flag) return\n        if (node == null) return true\n        inOrder(node.left)\n        if (node.val <= preVal) {\n            //如果当前节点的值小于等于上一个节点的值，当然不满足BST\n            flag = false\n        }\n        preVal = node.val\n        inOrder(node.right)\n    }\n    inOrder(root)\n    return flag\n};\n```\n\n## 二叉搜索树中的插入操作\n\n题目描述：给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。\n\n> 方法一：递归\n> 思路分析：利用递归函数的返回值完成新加入的节点与其父节点的赋值操作，下一层将新加入的节点返回，本层用root->left或者root->right接住\n> 复杂度分析：\n>\n> - 时间复杂度：O(N)，N为二叉树中节点的个数，最坏情况下，需要将值插入到树的最深的叶子节点上，而叶子节点最深为O(N)\n> - 空间复杂度：O(1),只使用了常数大小的空间\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} val\n * @return {TreeNode}\n */\nvar insertIntoBST = function(root, val) {\n    if (root == null) {\n        let node = new TreeNode(val)\n        return node\n    }\n    if (root.val > val) {\n        root.left = insertIntoBST(root.left, val)\n    }\n    if (root.val < val) {\n        root.right = insertIntoBST(root.right, val)\n    }\n    return root\n};\n```\n\n## 删除二叉搜索树中的节点\n\n题目描述：给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n\n> 方法一：递归\n> 思路分析：\n> 要删除的节点有三种情况：\n>\n> - 要删除的节点为叶子节点，直接去世\n> - 要删除的节点为单分支节点，要让孩子接替自己的位置\n> - 要删除的节点为双分支节点，必须用左子树中最大的节点或者右子树中最小的节点替换自己，这里我们选择第二种\n>\n> 复杂度分析：\n>\n> - 时间复杂度：O(N)\n> - 空间复杂度：O(1)\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} key\n * @return {TreeNode}\n */\nlet getMinNode = (node) => {\n  //获得右子树中最小的节点，最左边的节点就是最小的节点\n    while(node.left != null) node = node.left\n    return node\n}\nvar deleteNode = function(root, key) {\n    // base case\n    if (root == null) return null\n    if (root.val == key) {\n        //这两个if,判断了前两种的情况\n        if (root.left == null) return root.right\n        if (root.right == null) return root.left\n        let minNode = getMinNode(root.right)\n        root.right = deleteNode(root.right, minNode.val)\n        minNode.right = root.right\n        minNode.left = root.left\n        root = minNode\n    }else if (root.val > key) {\n        //去下一层删除值为key的节点，并且返回下一层的根节点，本层用root.left或者root.right接住\n        root.left = deleteNode(root.left, key)\n    }else if (root.val < key) {\n        root.right = deleteNode(root.right, key)\n    }\n    return root\n};\n```\n\n## 不同的二叉搜索树\n\n题目描述：给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。\n\n> 方法一：带备忘录的递归\n> 思路分析：对于n = 5 的情况，如果当3作为根节点，左子树的节点组合为{1,2}，右子树的节点组合为{4,5}，\n> 左子树组合能构成BST的组合树有2种，右子树组合能构成BST的组合树也有两种，那么以3作为根节点的BST组合树有4种，可以推出，左子树的组合数和右子树的组合数乘积就是3作为根节点时的BST个数\n> 复杂度分析：\n>\n> - 时间复杂度：O(N2) -> O(N)，备忘录优化，\n> - 空间复杂度：O(N)\n\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar numTrees = function(n) {\n    let memo = new Array(n+1).fill(0).map(() => new Array(n+1).fill(0))\n    //递归函数定义：返回以[left, right]为区间构成的BST的个数\n    const BstCnt = (left, right) => {\n        if (left > right) return 1\n        if (memo[left][right] != 0) return memo[left][right]\n        for (let i = left; i <= right; i++) {\n            let leftSize = BstCnt(left, i - 1)\n            let rightSize = BstCnt(i + 1, right)\n            memo[left][right] += leftSize * rightSize\n            //左子树的组合数和右子树的组合数乘积就是当前节点作为根节点时的BST个数\n        }\n        return memo[left][right]\n    }\n    return BstCnt(1, n)\n};\n```\n\n## 不同的二叉搜索树II\n\n题目描述：给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 **二叉搜索树**_ _。可以按 **任意顺序** 返回答案。\n\n> 方法一：递归\n> 思路分析：\n>\n> 1. 穷举根节点所有的可能\n> 1. 递归构造左右子树的BST组合\n> 1. 给root节点穷举所有的左右子树的组合\n>\n> 复杂度分析：\n>\n> - 时间复杂度：O(N2)\n> - 空间复杂度：O(N)\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number} n\n * @return {TreeNode[]}\n */\nvar generateTrees = function(n) {\n    /* 构造闭区间 [lo, hi] 组成的 BST */\n    const build = (lo, hi) => {\n        let res = []\n        if (lo > hi) {\n            res.push(null)\n            return res\n        }\n        //穷举根节点的所有可能\n        for (let i = lo; i <= hi; i++) {\n            //递归构造左右子树所有合法的BST组合\n            let left = build(lo, i - 1)\n            let right = build(i + 1, hi)\n\n            for (let leftItem of left) {\n                for (let rightItem of right) {\n                    //给根节点穷举所有的左右子树的组合\n                    let root = new TreeNode(i)\n                    root.left = leftItem\n                    root.right = rightItem\n                    res.push(root)\n                }\n            }\n        }\n        return res\n    }\n    return build(1,n)\n};\n```\n\n## 二叉搜索子树的最大键值和\n\n题目描述：给你一棵以 root 为根的 **二叉树** ，请你返回 **任意** 二叉搜索子树的最大键值和\n\n> 解法一：递归\n> 思路分析：二叉树相关题目最核心的思路就是明确当前节点需要做的事情是什么，如果当前节点要做的事情需要通过左右子树的计算结果推导出来，就要用到后序遍历。就是找到**节点之和最大的**那颗二叉搜索树，返回它的节点值之和。\n>\n> 1. 左右子树是否是BST\n> 1. 左子树的最大值和右子树的最小值\n> 1. 左右子树的节点值之和\n>\n> 复杂度分析：\n>\n> - 时间复杂度：O(N)\n> - 空间复杂度：O(N)\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxSumBST = function(root) {\n    let maxSum = 0\n    let traverse = (root) => {\n        if (root == null) return [1, Infinity, -Infinity, 0]\n        //递归计算左右子树\n        let left = traverse(root.left)\n        let right = traverse(root.right)\n        let res = new Array(4)\n        if (left[0] == 1 && right[0] == 1 && root.val > left[2] && root.val < right[1]) {\n            res[0] = 1 //以root为根的树是否是BST\n            res[1] = Math.min(left[1], root.val) //以root为根的二叉树所有节点的最小值\n            res[2] = Math.max(right[2], root.val)//以root为根的二叉树所有节点的最大值\n            res[3] = root.val + left[3] + right[3]//以root为根的二叉树所有节点值之和\n            maxSum = Math.max(maxSum, res[3])   \n        }\n        return res\n    }\n    traverse(root)\n    return maxSum\n};\n```\n\n## 求根结点到叶节点数字之和\n\n题目描述：计算从根节点到叶节点生成的 **所有数字之和** \n\n> 方法一：回溯\n> 思路分析：你想，让我获取所有路径数字之和，那我递归遍历一遍二叉树，沿路记录下来路径上的数字，到叶子节点的时候求和，不就完事了？\n> 复杂度分析：O(N)，对每个节点访问一次\n> 空间复杂度：O(N)，空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数。\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    let sum = 0\n    let dfs = (root, path) => {\n        if (root == null) return\n        //前序遍历位置，记录节点值\n        path.push(root.val)\n        //	到叶子节点的时候计算路径和\n        if (root.left === null && root.right === null) {\n            sum += parseInt(path.join(\'\'),10)\n        }\n        dfs(root.left, path)\n        dfs(root.right, path)\n        //	后序遍历位置，撤销节点值\n        path.pop()\n    }\n    dfs(root, [])\n    return sum\n};\n```\n\n## 完全二叉树的节点个数\n\n题目描述：给你一棵** 完全二叉树** 的根节点 root ，求出该树的节点个数\n\n> 方法一：递归或迭代\n> 思路分析：遍历一遍统计节点个数，或者利用定义计算节点个数，以root为根的二叉树的节点个数等于以root.left为根的二叉树节点个数加上以root.right为根的二叉树节点个数+1\n> 复杂度分析：\n>\n> - 时间复杂度：O(N)\n> - 空间复杂度：O(1)\n>\n> 方法二：利用满二叉树的高度公式，高度为h的满二叉树的节点数为2^h - 1\n> 思路分析：完全二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和满二叉树的结合版\n> 复杂度分析：\n>\n> - 时间复杂度\n> - 空间复杂度\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar countNodes = function(root) {\n    let [hl, hr] = [0,0]\n    let [l, r] = [root, root]\n    //记录左右子树的高度\n    while(l) {\n        hl++\n        l = l.left\n    }\n    while(r) {\n        hr++\n        r = r.right\n    }\n    //左右子树的高度相同，按照满二叉树的公式计算\n    if (hl == hr) {\n        return Math.pow(2, hl) - 1\n    }else {\n        //如果左右子树的高度不同，则按照普通二叉树的逻辑计算\n        return 1 + countNodes(root.left) + countNodes(root.right)\n    }\n};\n```\n\n## 恢复二叉搜索树\n\n题目描述：给你二叉搜索树的根节点 root ，该树中的 **恰好** 两个节点的值被错误地交换。_请在不改变其结构的情况下，恢复这棵树 _。\n**中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。**\n\n> 方法一：递归\n> 思路分析：BST的中序遍历顺序是一个升序序列，题目说有两个节点的值反了，也就是说中序遍历结果不再是有序的，有两个元素的位置反了。那么我们在中序遍历的时候找到破坏有序性的这两个元素，交换它们即可。\n\n> 复杂度分析：\n>\n> - 时间复杂度：O(N)\n> - 空间复杂度：O(1)\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\nvar recoverTree = function(root) {\n    let [first, second] = [null, null]\n    let prev = new TreeNode(-Infinity)\n    const inorderTraverse = (root) => {\n        if (root == null) return\n\n        inorderTraverse(root.left)\n        //中序遍历位置\n        //root不符合有序性\n        if (root.val < prev.val) {\n            if (first == null) {\n                //第一个错位位置是prev\n                first = prev\n            }\n            //第二个错位位置是root\n            second = root\n        }\n        prev = root\n        inorderTraverse(root.right)\n    } \n    inorderTraverse(root)\n    let temp = first.val\n    first.val = second.val\n    second.val = temp\n};\n```\n\n## 打家劫舍III\n\n题目描述：给定二叉树的 root 。返回 _**在不触动警报的情况下** ，小偷能够盗取的最高金额_ 。\n\n> 方法一：递归->记忆化递归\n> 思路分析：能盗取的最高金额为 抢劫该节点+抢劫该节点的左孩子的左右子树+抢劫该节点的右孩子的左右子树与抢劫该节点的左子树+抢劫该节点的右子树的和的最大值\n> 复杂度分析：\n>\n> - 时间复杂度: O(N)\n> - 空间复杂度: O(N)\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\n\nvar rob = function(root) {\n    let map = new Map()\n    const helper = (root) => {\n        if (root == null) return 0\n        if (map.has(root)) return map.get(root)\n        let [yesVAl, noVal] = [0,0]\n        //抢当前节点\n        yesVAl += root.val\n        if (root.left != null) yesVAl += helper(root.left.left) + helper(root.left.right)\n        if (root.right != null) yesVAl += helper(root.right.left) + helper(root.right.right)\n        \n        //不抢当前结点\n        noVal += helper(root.left) + helper(root.right)\n        let res = Math.max(yesVAl, noVal)\n        map.set(root, res) \n        return res\n    }\n    return helper(root)\n};\n```\n\n# 贪心\n\n什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。\n\n## 无重叠区间\n\n题目描述：给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。\n\n> 方法一：贪心\n> 思路分析：题目要求需要移除区间的最小数量，可以先求出**无重叠区间**的个数。这道题是一道经典的贪心之区间调度问题。比如你今天有好几个活动，每个活动都可以用区间 [start, end] 表示开始和结束的时间，请问你今天**最多能参加几个活动**呢？显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。\n> **正确的思路其实很简单，可以分为以下三步：**\n> **1、从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。**\n> **2、把所有与 x 区间相交的区间从区间集合 intvs 中删除。**\n> **3、重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。**\n> 复杂度分析：\n>\n> - 时间复杂度：O(NlogN)\n> - 空间复杂度：O(logN)\n\n```javascript\n/**\n * @param {number[][]} intervals\n * @return {number}\n */\nvar eraseOverlapIntervals = function(intervals) {\n    //按右边界排序（这里没有选择按区间长度升序排序，这种贪心思路不对）\n    intervals.sort((a,b) => a[1] - b[1])\n    //无重叠区间个数至少为1\n    let cnt = 1\n    //排序后第一个区间就是X\n    let x_end = intervals[0][1]\n    for (interval of intervals) {\n        let start = interval[0]\n        if (start >= x_end) {\n            //找到下一个选择的区间\n            cnt++\n            x_end = interval[1]\n        }\n        \n    }\n    return intervals.length - cnt\n};\n```\n\n## 用最少数量的箭引爆气球\n\n题目描述：给你一个数组 points ，_返回引爆所有气球所必须射出的 **最小** 弓箭数 _。\n\n> 方法一：贪心\n> 思路分析：题目就是要你求无重叠区间的个数，此题的区别就是，当两个区间擦边，就算重叠，只需要把>=改为>\n> 复杂度分析：\n>\n> - 时间复杂度：O(NlogN)\n> - 空间复杂度：O(logN)\n\n```javascript\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar findMinArrowShots = function(points) {\n    points.sort((a,b) => a[1] - b[1])\n    let cnt = 1\n    let X_end = points[0][1]\n    for (let point of points) {\n        let start = point[0]\n        // >= 改为 > 就行了\n        if (start > X_end) {\n            cnt++\n            X_end = point[1]\n        }\n    }\n    return cnt\n};\n```\n\n## 跳跃游戏\n\n题目描述：给定一个非负整数数组 nums ，你最初位于数组的 **第一个下标** 。\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n判断你是否能够到达最后一个下标。\n\n> 方法一：动态规划\n> 思路分析：dp[i]判断当前位置是否可到达\n> 复杂度分析：\n>\n> - 时间复杂度：O(N2)\n> - 空间复杂度：O(N)\n>\n> 方法二：贪心：\n> 思路分析：刚看到本题一开始可能想：当前位置元素如果是3，我究竟是跳一步呢，还是两步呢，还是三步呢，究竟跳几步才是最优呢？\n> 其实跳几步无所谓，关键在于**可跳的覆盖范围**！\n> 不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。\n> 这个范围内，别管是怎么跳的，反正一定可以跳过来。\n> 那么这个问题就转化为**跳跃覆盖范围究竟可不可以覆盖到终点**！\n> 每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。\n> **贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。**\n> 局部最优推出全局最优，找不出反例，试试贪心！\n> 复杂度分析：\n>\n> - 时间复杂度：O(N)\n> - 空间复杂度：O(1)\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function(nums) {\n    if (nums.length == 1) return true\n    //覆盖范围, 初始覆盖范围应该是0，因为下面的迭代是从下标0开始的\n    let cover = 0\n    //在覆盖范围内更新最大的覆盖范围\n    for (let i = 0; i <= cover; i++) {\n        cover = Math.max(cover, i + nums[i])\n        if (cover >= nums.length - 1) return true\n    }\n    return false\n};\n```\n\n## 跳跃游戏II\n\n题目描述：\n给定一个非负整数数组，你最初位于数组的第一个位置。\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n你的目标是使用最少的跳跃次数到达数组的最后一个位置。\n\n> 方法一：自顶向下的递归动态规划\n> 思路分析：定义一个动态规划函数dp(nums,p)表示从当前索引p跳到最后一格，至少需要多少步\n> ，我们要求的结果就是dp(nums, 0)，base case就是当p越过最后一格，不需要跳跃。暴力穷举所有可能的跳法，通过备忘录 memo 消除重叠子问题，取其中的最小值最为最终答案\n> 复杂度分析：\n>\n> - 时间复杂度：O(N2)，递归深度 * 每次递归需要的时间复杂度\n> - 空间复杂度：O(N)\n>\n> 方法二：贪心\n> 思路分析：要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数！这里需要统计两个覆盖范围，当前这一步的最大覆盖距离和下一步的最大覆盖距离。\n> 复杂度分析：\n>\n> - 时间复杂度：O(N)\n> - 空间复杂度：O(1)\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function(nums) {\n    let n = nums.length\n    if (n == 1) return 0\n    //当前这一步的最大覆盖距离\n    let curDistance = 0\n    //下一步的最大覆盖距离\n    let nextDistance = 0\n    let ans = 0\n    for (let i = 0; i < n - 1; i++) {\n        //更新下一步的最大覆盖距离\n        nextDistance = Math.max(nextDistance, i + nums[i])\n        if(i == curDistance) {//遇到当前覆盖的最远距离\n            ans++\n            curDistance = nextDistance//更新当前覆盖的最大距离\n        }\n    }\n    return ans\n};\n```\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function(nums) {\n    let n = nums.length\n    let memo = new Array(n).fill(n)\n    let dp = (nums, p) => {\n        if (p >= n - 1) return 0\n        if (memo[p] != n) return memo[p]\n        let subProblem = n\n        for (let i = 1; i <= nums[p]; i++) {\n            subProblem = Math.min(subProblem, dp(nums, p + i)) \n        }\n        memo[p] = subProblem + 1\n        return memo[p]\n    }\n    return dp(nums, 0)\n};\n```\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function(nums) {\n    let n = nums.length\n    let memo = new Array(n).fill(n)\n    let dp = (nums, p) => {\n        if (p >= n - 1) return 0\n        //子问题计算过，直接返回\n        if (memo[p] != n) return memo[p]\n        \n        //你可以选择跳1步，2步，...\n        for (let i = 1; i <= nums[p]; i++) {\n            //穷举每一个选择\n            //计算每一个子问题的结果\n            subProblem = dp(nums, p + i)\n            //取其中最小的作为最终结果\n            memo[p] = Math.min(subProblem + 1, memo[p])\n        }\n        return memo[p]\n    }\n    return dp(nums, 0)\n};\n```\n\n## 合并区间\n\n题目描述：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。\n\n> 方法：贪心\n> 思路分析：以左端点进行排序，分析区间之间的相交情况\n> 复杂度分析：\n>\n> - 时间复杂度：O(NlogN)\n> - 空间复杂度：O(logN)，这里计算的是除了存储答案之外，所需的额外空间，即排序所需的空间复杂度\n\n```javascript\n/**\n * @param {number[][]} intervals\n * @return {number[][]}\n */\nvar merge = function(intervals) {\n    intervals.sort((a, b) => a[0] - b[0])\n    let n = intervals.length\n    let res = []\n    let [left, right] = [intervals[0][0], intervals[0][1]]\n    for (let i = 1; i < n; i++) {\n        let interv = intervals[i]\n        //遇到相交区间\n        if (interv[0] <= right && interv[1] >= right) {\n            right = interv[1]\n            \n        }\n        //遇到不重合区间，添加前一个区间的左右端点\n        if (interv[0] > right) {\n            res.push([left, right])\n            left = interv[0]\n            right = interv[1]\n        }\n    }\n    //易错点：考察到最后一个区间时，后面没有区间了，遇不到重合区间，直接加入\n    res.push([left, right])\n    return res\n};\n```\n\n## 视频拼接\n\n题目描述：我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, time]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。\n\n> 方法一：贪心\n> 思路分析：\n>\n> - 区间问题肯定按照区间的起点或者终点排序\n> - 要用若干短视频凑出完整视频[0,time]，至少得有一个短视频的起点是0\n> - 如果有几个短视频的起点都相同，那么一定应该选择那个最长\n> - 也就是说起点相同的，按照终点降序排\n>\n> 复杂度分析：\n>\n> - 时间复杂度：O(NlogN)\n> - 空间复杂度：O(logN)\n\n```javascript\n/**\n * @param {number[][]} clips\n * @param {number} time\n * @return {number}\n */\nvar videoStitching = function(clips, time) {\n  // 特殊情况\n  if (time == 0) {\n    return 0;\n  }\n  clips.sort((a, b) => {\n    // 按起点升序排列，起点相同的降序排列\n    return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];\n  });\n  let res = 0;\n  // 当前段的结尾数字    默认为0  因为要用若干短视频凑出完成视频[0, T]，至少得有一个短视频的起点是 0\n  let curEnd = 0,\n    // 下一个时段的结尾数字\n    nextEnd = 0;\n  let i = 0,\n    n = clips.length;\n  while (i < n && clips[i][0] <= curEnd) {\n    // 在第 res 个视频的区间内贪心选择下一个视频\n    while (i < n && clips[i][0] <= curEnd) {\n      nextEnd = Math.max(nextEnd, clips[i][1]);\n      i++;\n    }\n    // 找到下一个视频，更新 curEnd\n    res++;\n    curEnd = nextEnd;\n    if (curEnd >= time) {\n      // 已经可以拼出区间 [0, T]\n      return res;\n    }\n  }\n  return -1;\n};\n\n```\n\n## 加油站\n\n题目描述：给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则保证它是唯一的。\n\n> 方法一：画图\n> 思路分析：\n>\n> - 汽车进入站点 i 可以加 gas[i] 的油（图中绿色数字），离开站点会损耗 cost[i] 的油（图中红色数字），那么可以把站点和与其相连的路看做一个整体，将 gas[i] - cost[i] 作为经过站点 i 的油量变化值\n> - **有了这个环形数组，我们需要判断这个环形数组中是否能够找到一个起点 start，使得从这个起点开始的累加和一直大于等于 0**。\n> - 以图中最低的点作为坐标轴原点，下一个点作为起点\n>\n> 复杂度分析：\n>\n> - 时间复杂度：O(N)\n> - 空间复杂度：O(1)\n> - ![fb28630029bfc671ff09f59ab68c2f4.png](https://cdn.nlark.com/yuque/0/2022/png/27575143/1650798714039-b54e43d9-a34c-4d88-b158-7f77b70e3d16.png#clientId=ub9046f47-42f4-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5243c447&margin=%5Bobject%20Object%5D&name=fb28630029bfc671ff09f59ab68c2f4.png&originHeight=464&originWidth=872&originalType=binary&ratio=1&rotation=0&showTitle=false&size=691067&status=done&style=none&taskId=ua8bfd037-1384-4f7a-b797-8620f0001eb&title=)\n> - \n\n> ![bea026a24a204b209e6a5d28c2b7b82.png](https://cdn.nlark.com/yuque/0/2022/png/27575143/1650798745339-6649e418-f676-49e1-9b13-5cbb03d488fb.png#clientId=ub9046f47-42f4-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua01a28dd&margin=%5Bobject%20Object%5D&name=bea026a24a204b209e6a5d28c2b7b82.png&originHeight=443&originWidth=809&originalType=binary&ratio=1&rotation=0&showTitle=false&size=601157&status=done&style=none&taskId=u52808934-19b3-4cb5-9f71-a2e29652565&title=)\n\n```javascript\n/**\n * @param {number[]} gas\n * @param {number[]} cost\n * @return {number}\n */\nvar canCompleteCircuit = function(gas, cost) {\n    let n = gas.length\n    let sum = 0\n    //当sum([...gas]) < sum([...cost])，肯定无法跑完全程\n    for (let i = 0; i < gas.length; i++) {\n        sum += gas[i] - cost[i]\n    }\n    if (sum < 0) return -1\n    let tank = 0\n    let start = 0\n    for (let i = 0; i < n; i++) {\n        tank += gas[i] - cost[i]\n        if (tank < 0) {\n            // 无法从 start 走到 i\n            // 所以站点 i + 1 应该是起点\n            start = i + 1\n            tank = 0\n        }\n    }\n    return start == n ? 0 : start\n};\n```\n\n# 分治（归并排序）\n\n## 排序列表\n\n题目描述：给你链表的头结点head,请将其按升序排列并返回排序后的链表 。\n\n> 思路分析：\n> 看到时间复杂度的要求，而且是链表，归并排序比较好做。\n> 都知道归并排序要**先归（二分），再并**。两个有序的链表是比较容易合并的。\n> 二分到不能再二分，即递归压栈压到链只有一个结点（有序），于是在递归出栈时进行合并。\n> ![1605902567-HjZkuk-image.png](https://cdn.nlark.com/yuque/0/2022/png/27575143/1650938161574-6c6fe9ff-1bd8-44b8-8938-0f4b7108e6dc.png#clientId=u1c7f6578-94e3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u19c6faec&margin=%5Bobject%20Object%5D&name=1605902567-HjZkuk-image.png&originHeight=786&originWidth=1952&originalType=binary&ratio=1&rotation=0&showTitle=false&size=182220&status=done&style=none&taskId=u1d8bd08b-fb41-45a9-b93c-d3af90d7ffd&title=)二分、merge 函数\n>\n> - 二分，用快慢指针法，快指针走两步，慢指针走一步，快指针越界时，慢指针正好到达中点，只需记录**慢指针的前一个指针**，就能断成两链。\n> - merge 函数做的事是合并两个有序的左右链\n> - 设置虚拟头结点，用 prev 指针去“穿针引线”，prev 初始指向 dummy,每次都确定 prev.Next 的指向，并注意 l1，l2指针的推进，和 prev 指针的推进\n>\n> ![1605904108-hkxyHV-image.png](https://cdn.nlark.com/yuque/0/2022/png/27575143/1650938161530-a374f251-b59d-4315-9788-3b5b8659e59f.png#clientId=u1c7f6578-94e3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u11e63b1c&margin=%5Bobject%20Object%5D&name=1605904108-hkxyHV-image.png&originHeight=674&originWidth=1884&originalType=binary&ratio=1&rotation=0&showTitle=false&size=188544&status=done&style=none&taskId=uc15c4f28-637c-458e-bdf4-6a43f75157c&title=)\n> 合并两个有序的链表，合并后的结果返回给父调用，一层层向上，最后得出大问题的答案。\n> 复杂度分析：\n>\n> - 时间复杂度：O(NlogN)\n> - 空间复杂度：O(logN)，树的高度\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar sortList = function(head) {\n    if (!head || !head.next) return head\n    let [slow, fast] = [head, head]\n    let preslow\n    while (fast && fast.next) {\n        preslow = slow\n        slow = slow.next\n        fast = fast.next.next\n    } \n    preslow.next = null\n    //先二分，再并\n    const l = sortList(head)\n    const r = sortList(slow)\n    return merge(l, r)\n};\n\nfunction merge(l1, l2) {\n    //合并两个有序链表，建立哑节点，利用prev穿针引线\n    let dummy = new ListNode(-1)\n    let prev = dummy\n    while (l1 && l2) {\n        if (l1.val < l2.val) {\n            prev.next = l1\n            prev = l1\n            l1 = l1.next\n        }else {\n            prev.next = l2\n            prev = l2\n            l2 = l2.next\n        }\n    }\n    if (l1) prev.next = l1\n    if (l2) prev.next = l2\n    return dummy.next\n}\n```\n\n# 排序\n\n## 前K个高频元素\n\n题目描述：给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n\n> 方法一：粗暴排序法\n> 思路分析：最简单粗暴的思路就是 使用排序算法对元素按照频率由高到低进行排序，然后再取前 k 个元素。\n> 复杂度分析：\n>\n> - 时间复杂度：O(nlogn)，n 表示数组长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是O(n)；接着，排序算法时间复杂度为 O(nlogn)；因此整体时间复杂度为 O(nlogn)。\n> - 空间复杂度：O(n)，最极端的情况下（每个元素都不同），用于存储元素及其频率的 Map 需要存储 n个键值对。\n>\n> 方法二：堆排序：\n> 思路分析：\n>\n> - 求前 k 大，用小根堆，求前 k 小，用大根堆。\n> - 借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率\n> - 维护一个元素数目为 k的最小堆\n> - 每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较\n> - 如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中\n> - 最终，堆中的 k个元素即为前 k 个高频元素\n>\n> 复杂度分析：\n>\n> - 时间复杂度：O(nlogk)，n 表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；接着，遍历用于存储元素频率的 map，如果元素的频率大于最小堆中顶部的元素，则将顶部的元素删除并将该元素加入堆中，这里维护堆的数目是 k，所以这一系列操作的时间复杂度是 O(nlogk) 的；因此，总的时间复杂度是 O(nlog⁡k)。\n> - 空间复杂度：O(n)，最坏情况下（每个元素都不同），map 需要存储 n 个键值对，优先队列需要存储 k个元素，因此，空间复杂度是 O(n)。\n\n```javascript\nvar topKFrequent = function(nums, k) {\n    let map = new Map()\n    nums.forEach(n => {map.set(n, (map.get(n) || 0) + 1)})\n    //这一步使用了快速排序\n    let temp = Array.from(map).sort((a,b) => b[1] - a[1])\n    return temp.slice(0,k).map(n => n[0])\n};\n```\n\n# 单调栈\n\n题目描述：给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n\n> 方法一：单调栈\n> 思路分析：\n>\n> - 以矩阵中的每一行为底，计算以当前行为底的直方图中的最大矩形最大面积来计算矩阵的最大矩形面积\n> - 将矩阵中上下相邻的为‘1’的格子看作直方图中的柱子\n>\n> 复杂度分析：\n>\n> - 时间复杂度：O(MN)\n> - 空间复杂度：O(MN)\n\n```javascript\n/**\n * @param {character[][]} matrix\n * @return {number}\n */\nvar maximalRectangle = function(matrix) {\n    const [m,n] = [matrix.length, matrix[0].length]\n    let area = 0\n    let heights = new Array(n).fill(0)\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n           if (matrix[i][j] == \'1\') {\n               heights[j] += 1\n           }else {\n               heights[j] = 0\n           }\n        }\n        //逐行计算直方图中最大矩形的面积\n        area = Math.max(area, largestRectangleArea(heights))\n    }\n    return area\n};\n\nvar largestRectangleArea = function(heights) {\n    let maxArea = 0\n    let stk = []\n    heights = [0, ...heights, 0]//前后补0，将栈中的所有元素出栈\n    for (let i = 0; i < heights.length; i++) {\n        while (stk.length && heights[stk[stk.length-1]] > heights[i]){\n            let stkTop = stk.pop()\n            maxArea = Math.max(maxArea, \n            heights[stkTop] * (i - stk[stk.length-1] - 1))\n        }\n\n        stk.push(i)\n    }\n    return maxArea\n};\n```', '2022-08-09 22:46:32', 999);
COMMIT;

-- ----------------------------
-- Table structure for type
-- ----------------------------
DROP TABLE IF EXISTS `type`;
CREATE TABLE `type` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '类型编号',
  `typeName` varchar(255) DEFAULT NULL COMMENT '文章类型名称',
  `orderNum` int DEFAULT NULL COMMENT '类型排序编号',
  `icon` varchar(255) DEFAULT NULL COMMENT '图标名',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb3 COMMENT='文章类型表\n';

-- ----------------------------
-- Records of type
-- ----------------------------
BEGIN;
INSERT INTO `type` VALUES (1, '技术', 1, 'youtube');
INSERT INTO `type` VALUES (2, '生活', 2, 'message');
INSERT INTO `type` VALUES (3, '规划', 3, 'smile');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
